#!bin/python

##CODE GENERATED by gladizer 1.2


import re
import os
from random import choice as random_choice
from itertools import cycle

import pygtk
pygtk.require('2.0')

import gtk, gtk.glade
import gobject
import pango

from regextoolkitlib import *

class RegexToolkit(object):

    def __init__(self):
    
        #Widget tree..
        self.wTree=gtk.glade.XML(os.path.join(os.path.dirname(__file__),'ui', 'gregextoolkitdialog.glade'))

        #connect signals and handlers.
        self.wTree.signal_autoconnect(self)

        self.gregextoolkitdialog=self.wTree.get_widget('gregextoolkitdialog')
        self.vbox1=self.wTree.get_widget('vbox1')
        self.lblRegex=self.wTree.get_widget('lblRegex')
        self.regex=self.wTree.get_widget('regex')
        self.scroll_regex=self.wTree.get_widget('scroll_regex')
        self.txtRegex=self.wTree.get_widget('txtRegex')
        self.regex_choices=self.wTree.get_widget('regex_choices')
        self.chkMULTILINE=self.wTree.get_widget('chkMULTILINE')
        self.chkDOTALL=self.wTree.get_widget('chkDOTALL')
        self.chkVERBOSE=self.wTree.get_widget('chkVERBOSE')
        self.chkUNICODE=self.wTree.get_widget('chkUNICODE')
        self.chkIGNORECASE=self.wTree.get_widget('chkIGNORECASE')
        self.chkLOCALE=self.wTree.get_widget('chkLOCALE')
        self.lblInput=self.wTree.get_widget('lblInput')
        self.scroll_input=self.wTree.get_widget('scroll_input')
        self.txtInput=self.wTree.get_widget('txtInput')
        self.lblResult=self.wTree.get_widget('lblResult')
        self.scroll_results=self.wTree.get_widget('scroll_results')
        self.tvResult=self.wTree.get_widget('tvResult')
        self.buttons=self.wTree.get_widget('buttons')
        self.btnExecute=self.wTree.get_widget('btnExecute')
        self.btnRegexLib=self.wTree.get_widget('btnRegexLib')
        self.statusbar=self.wTree.get_widget('statusbar')
        self.btnRegexLib.set_sensitive(False)
        self.flags=0
        self.flagsdict={}
        self.chks=[self.chkMULTILINE, self.chkVERBOSE, self.chkDOTALL, self.chkIGNORECASE, self.chkLOCALE, self.chkUNICODE]
        
            
        for chk in self.chks:
            self.flagsdict[chk.get_label()]=True
            
            
        #TreeView columns.
        midcell=gtk.CellRendererText()
        midcol=gtk.TreeViewColumn("#mid", midcell, text=0)
        self.tvResult.append_column(midcol)
        
        self.txtInput.get_buffer().create_tag("red_fg", foreground="red")#size=15*pango.SCALE)
        self.txtInput.get_buffer().create_tag("blue_fg", foreground="blue")#size=15*pango.SCALE)
        self.txtInput.get_buffer().create_tag("darkgreen_fg", foreground="#33773B") #size=15*pango.SCALE)
        self.txtInput.get_buffer().create_tag("darkred_bg", foreground="#BB0A0A") #size=15*pango.SCALE )
        self.txtInput.get_buffer().create_tag("dbrow_fg", foreground="#7F6628")
        #self.txtInput.get_buffer().create_tag("lightbr_fg", foreground="#DBD39C", ) #size=15*pango.SCALE )
        self.txtInput.get_buffer().create_tag("vi_fg", foreground="#5F4E84")# size=15*pango.SCALE )
        
        self.buf_tags=["red_fg", "blue_fg", "darkgreen_fg", "vi_fg", "darkred_fg", "dbrow_fg"] # "lightbr_fg"
              
        
    def update_flags(self):
        for k, v in self.flagsdict.items():
            if not v:
                del self.flagsdict[k]
                
        self.flags=flags_from_dict(self.flagsdict) if self.flagsdict else 0
        #print self.flags
        
    def get_text_from_buffer(self, buffer):
        siter=buffer.get_start_iter()
        eiter=buffer.get_end_iter()
        return buffer.get_text(siter, eiter)

    def highlightmatch(self, ms):

        buf = self.txtInput.get_buffer()
        buf.remove_all_tags(buf.get_start_iter(), buf.get_end_iter())
        tagscycle=cycle(self.buf_tags)
        for m in ms:
            for idx in range(len(m.groups())):
                pos = idx+1
                tag=tagscycle.next()
                ##FIXME: ronny coloring evalutes to 0/1 tags only
                #tag=idx%len(self.buf_tags)
                #tag = random_choice(range(len(self.buf_tags))) #idx%len(self.buf_tags)
                #print "Tag: ", tag
                istart=buf.get_iter_at_offset(m.start(pos))
                iend=buf.get_iter_at_offset(m.end(pos))
                #buf.apply_tag(buf.get_tag_table().lookup(self.buf_tags[curtagidx]), istart, iend)
                buf.apply_tag_by_name(tag, istart, iend)

    def on_btnExecute_clicked(self, widget, *args):
        #print "Called..."
        
        regex = self.get_text_from_buffer(self.txtRegex.get_buffer())
        inp = self.get_text_from_buffer(self.txtInput.get_buffer())
        ms=all_matches(regex, inp)
        if len(ms): 
            self.statusbar.push(1, "[+]MATCH")
            self.prep_tv_for_matches(ms)
            self.highlightmatch(ms)
        else:
            self.statusbar.push(1, "[-]NO MATCH")
            self.tvResult.set_model(None)
            #return

    def prep_tv_for_matches(self, ms):
        #self.remove_columns()
        reg=re.compile(self.get_text_from_buffer(self.txtRegex.get_buffer()))
        namedgroupsdict={}
        #print "REG GIDX: ", reg.groupindex
        for gname, idx  in reg.groupindex.items():
            namedgroupsdict[idx]=gname
        #tstore=gtk.TreeStore(gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_STRING, gobject.TYPE_STRING) #mid, gid, name, match 
        tstore=gtk.TreeStore(gobject.TYPE_STRING)
        miter = tstore.get_iter_first()
        for mid, m in enumerate(ms):

            miter=tstore.append(None, ["Match#"+str(mid)])

            #citer = tstore.iter_children(miter)
            groups=capture_groups(m)
            #for gi, gval in enumerate(groups):(?P<name>\w+?)(\d+)
            #interested in first match...
            for gi in range(len(groups)+1):
                gval=m.group(gi)
                tstore.append(miter, ["%d: %s (%s)"%(gi , gval, namedgroupsdict.get(gi, "Anonymouse") )])


        self.tvResult.set_model(tstore)

    def on_chk_toggled(self, widget, *args):
        self.flagsdict[widget.get_label().upper()]=widget.get_active()
        self.update_flags()

    def _remove_columns(self):
        #colslist=self.tvResult.get_columns()
        #map(self.tvResult.remove_column, colslist)
        map(self.tvResult.remove_column, self.tvResult.get_columns())
        
    def on_btnRegexLib_clicked(self, widget, *args):
        pass

    def remove_columns(self):
        colslist=self.tvResult.get_columns()
        map(self.tvResult.remove_column, colslist)


    def get_dialog(self):
        return self.gregextoolkitdialog
 

# run main loop

def main():
    regextkd = RegexToolkit()
    #mainwindow.regextoolkitdialog.show()
    print regextkd.get_dialog().run()
    gtk.main()

if __name__ == "__main__":
    main()

